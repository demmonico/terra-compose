#!/usr/bin/env bash
#-----------------------------------------------------------#
# @author: demmonico, @email demmonico@gmail.com, Â©2021-2025
# @repo https://github.com/demmonico/terra-compose
#-----------------------------------------------------------#

read -r -d '' HELP_STRING <<'EOF'
-----------------------------------------------------------
Help information
-----------------------------------------------------------
TerraCompose is a tool aimed to help to run Terraform commands in Docker and protect you against changes wrongly.

FORMAT: tc <ACTION> <ALIAS> [<OPTIONS|FLAGS>] [-- any args -or --options will be passed as-is]

<ACTION> - TerraCompose action you want to run with your IaaC tool (`Terraform` or `OpenTofu`):
    - plan          - build IaaC tool plan
    - apply         - apply IaaC tool plan
    - workspaces    - equal to `workspace list`
    - run           - proxy all arguments directly to IaaC tool. 
                      Allows running any custom command
    - shell         - run a shell inside the container runtime.
                      Allows running any custom commands inside
    - help          - this help information
<ALIAS>  - a unique shortcut to project/environment pair, like `runner_prod`

<OPTIONS|FLAGS> - Following are available:
    -q|--quick      - quick mode flag, skipping init and validation and format checks.

EOF

#-----------------------------------------------------------#
# Init

set -e

RC='\033[0;31m'
YC='\033[0;33m'
NC='\033[0m' # No Color

_DIR="$(pwd)"
BASE_DIR="${_DIR}"

init_app() {
    ALIAS_CONFIG="${ALIAS_CONFIG:-$( get_sys_config "${BASE_DIR}/tc.yaml" 'config' 'file' )}"
    HELP_STRING="${HELP_STRING}$( echo -e "\n\nList of available aliases from ${YC}${ALIAS_CONFIG}${NC}:\n>>>>>"; get_config; echo "<<<<<" )"

    VERBOSITY_DEBUG_MODE=0
    VERBOSITY_INFO_MODE=1
    VERBOSITY_ERROR_MODE=5
    VERBOSITY_MODE="${VERBOSITY:-$( get_sys_config "${VERBOSITY_INFO_MODE}" 'app' 'verbosity' )}"

    TF_PLAN_FILENAME='plan.tfplan'
    _SKIP_VALUE="$( get_sys_config '-' 'config' 'skip_value' )"
}


init_project() {
    local proj_subpath="$( get_config 'path' )"
    if [ -z "${proj_subpath}" ]; then
        echo -e "${RC}Error${NC}: no path was found for alias ${YC}${TC_ALIAS}${NC}"
        exit 2
    fi
    PROJ_DIR="${BASE_DIR}/${proj_subpath}"
    if [ -z "${PROJ_DIR}" ] || [ ! -d "${PROJ_DIR}" ]; then
        echo -e "${RC}Error${NC}: empty project DIR or was found for alias ${YC}${TC_ALIAS}${NC}"
        exit 2
    fi

    # AWS access
    AWS_PROFILE="${AWS_PROFILE:-"${AWS_DEFAULT_PROFILE}"}"
    local tc_check_aws_access="$( get_sys_config '1' 'app' 'init_aws_check' )"
    if (( "${tc_check_aws_access}" )); then # if check was not disabled
        # check AWS access env vars
        if [ -z "${AWS_PROFILE}" ] && [ -z "${AWS_ACCESS_KEY_ID}" ] && [ -z "${AWS_SECRET_ACCESS_KEY}" ]; then
            echo -e "${RC}Error${NC}: env var AWS_PROFILE/AWS_DEFAULT_PROFILE or AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY are empty. It's required to have either AWS access key set up or profile env vars, pointing to the actual AWS profile ('~/.aws/credentials')"
            exit 5
        fi
    fi

    PROJ_WORKSPACE="$( get_config 'workspace' )"
    PROJ_TFVAR="$( get_config 'tfvars' )"

    TF_PLAN_FILE="${PROJ_DIR}/${TF_PLAN_FILENAME}"

    # TF Tool selection: alias specific -> alias default -> system config -> terraform
    local tf_default_tool="$( get_yaml_value ${ALIAS_CONFIG} 'default' 'tftool' )"
    local tf_proj_tool="$( get_config 'tftool' )"
    TF_TOOL="${tf_proj_tool:-${tf_default_tool}}"
    TF_TOOL="${TF_TOOL:-$( get_sys_config 'terraform' 'tool' 'tftool' )}"

    # alias specific -> alias default -> system config -> hashicorp/terraform
    local tf_default_image="$( get_yaml_value ${ALIAS_CONFIG} 'default' 'tfimage' )"
    local tf_proj_image="$( get_config 'tfimage' )"
    TF_IMAGE="${tf_proj_image:-${tf_default_image}}"
    TF_IMAGE="${TF_IMAGE:-$( get_sys_config 'hashicorp/terraform' 'tool' 'tfimage' )}"

    local tf_default_version="$( get_yaml_value ${ALIAS_CONFIG} 'default' 'tfversion' )"
    local tf_proj_version="$( get_config 'tfversion' )"
    TF_VERSION="${tf_proj_version:-${tf_default_version}}"

    ### env vars

    # env vars file
    local default_env_vars_file="$( get_yaml_value ${ALIAS_CONFIG} 'default' 'env_vars_file' )"
    local proj_env_vars_file="$( get_config 'env_vars_file' )"
    local env_vars_file="${proj_env_vars_file:-${default_env_vars_file}}"
    if [ -z "${env_vars_file}" ]; then
        echo -e "${YC} >>> Didn't found env file param in config, searching for env filename param...${NC}"
        # env vars filename
        local default_env_vars_file_name="$( get_yaml_value ${ALIAS_CONFIG} 'default' 'env_vars_file_name' )"
        local proj_env_vars_file_name="$( get_config 'env_vars_file_name' )"
        local env_vars_file_name="${proj_env_vars_file_name:-${default_env_vars_file_name:-.env}}"
        env_vars_file="${BASE_DIR}/${env_vars_file_name}"
    fi
    ENV_VARS_FILE_DOCKER_PARAM=''
    if [ -f "${env_vars_file}" ]; then
      echo -e "${YC} >>> Found env file '${env_vars_file}', injecting it...${NC}"
      ENV_VARS_FILE_DOCKER_PARAM="--env-file ${env_vars_file}"
    else
      echo -e "${YC} >>> Didn't found env file '${env_vars_file}', skipping it...${NC}"
    fi

    # env vars str
    local proj_env_vars="$( get_config 'env' )"
    ENV_VARS_STR_DOCKER_PARAM=''
    if [ -n "${proj_env_vars}" ]; then
      echo -e "${YC} >>> Found env variables, injecting them...${NC}"
      ENV_VARS_STR_DOCKER_PARAM="$( echo "${proj_env_vars[@]}" | tr '\n' '&' | sed -E 's/^/\&/g' | sed -e 's/&$//g' -e 's/&/ -e /g' )"
    fi
}

run_host_hook() {
    local hook_name=$1
    local hook_cmd="$( get_config 'hooks' "${hook_name}" )"
    if [ -n "${hook_cmd}" ]; then
        echo -e "${YC} >>> Running host hook ${RC}${hook_name}${YC} ... ${NC}"
        bash -c "${hook_cmd}"
        echo -e "${YC} >>> Done ${NC}"
    fi
}

prepare_container_hook() {
    local hook_name=$1
    local hook_cmd="$( get_config 'hooks' "${hook_name}" )"
    if [ -n "${hook_cmd}" ]; then
        echo "${hook_cmd} && "
    fi
}

run_docker() {
    local cmd=$@

    if is_debug_VERBOSITY_MODE; then
        echo -e "${YC} >>> Command: ${RC}"
        # prevent to expand the color on the subshell when spinning up the interactive shell
        if [ -z "${cmd}" ]; then
            echo -n -e "${NC}"
        fi
        set -x
    fi

    docker run --rm -ti \
        $( if [[ `uname -m` == "arm64" ]]; then echo "--platform linux/amd64"; fi ) \
        -v "${BASE_DIR}":"${BASE_DIR}" \
        -v ~/.aws:/root/.aws \
        -v ~/.ssh:/root/.ssh \
        -e AWS_PROFILE=${AWS_PROFILE} \
        ${ENV_VARS_FILE_DOCKER_PARAM} \
        ${ENV_VARS_STR_DOCKER_PARAM} \
        -w=${PROJ_DIR} \
        --entrypoint /bin/sh \
        ${TF_IMAGE}:${TF_VERSION} \
        ${cmd:+-c} ${cmd:+"$( prepare_container_hook 'before_container_run' )${cmd}"}

    { if is_debug_VERBOSITY_MODE; then
        set +x;
        echo -e "${NC}"
    fi } 2>/dev/null

}

#-----------------------------------------------------------#
# Terraform

run_tf_init() {
    # skip when quick mode is enabled
    if is_quick_mode; then
        echo -e "${YC} >>> Running in ${RC}QUICK${YC} mode (skipping init backend, format check and validation)!${NC}"
        echo -e "\n------------------------------------------------------------------------\n"
        return
    fi

    run_host_hook 'before_tf_init'

    local backend_config="$( get_config 'backend_config' )"
    local result='' override_file=''
    if [ -n "${backend_config}" ]; then
        for file in ${backend_config[@]}; do
            result="${result} -backend-config=${file}"
            # lookup for an override files, adding it when exists
            override_file="$( get_override_file "${file}" )"
            [[ -f "${PROJ_DIR}/${override_file}" ]] && result="${result} -backend-config=${override_file}"
        done
    fi
    local backend_config_param="${result}"
    
    cd "${PROJ_DIR}" && \
        echo -e "Project dir is ${YC}${PROJ_DIR}${NC} and we are currently right here!" && echo "" && \
        echo -e "${YC} >>> Running ${RC}${TF_TOOL} init ${backend_config_param}${YC} ...${NC}" && \
        run_docker ${TF_TOOL} init ${backend_config_param}

    run_host_hook 'after_tf_init'
}

ask_input_workspace() {
    read -p "Please input workspace name: " CURRENT_WORKSPACE
    if [ -z "$( run_tf_workspace_list | grep -E "${CURRENT_WORKSPACE}" )" ]; then
        echo -e "${RC}Error${NC}: Ooops, wrong workspace name ${YC}${CURRENT_WORKSPACE}${NC}. Please try again!" >&2
        ask_input_workspace
    fi
}

run_tf_workspace_list() {
    run_docker ${TF_TOOL} workspace list
}

print_workspaces() {
    echo -e "\nTF workspaces:"
    run_tf_workspace_list
}

select_workspace() {
    # project-specific, set to skip
    if [ "${PROJ_WORKSPACE}" = "${_SKIP_VALUE}" ]; then
        echo -e "${YC} >>> Flag to skip workspace selection was found in config. Skiping it...${NC}"
        CURRENT_WORKSPACE="default (skipped)"
        return
    
    # project-specific
    elif [ -n "${PROJ_WORKSPACE}" ]; then
        echo -e "${YC} >>> Workspace '${RC}${PROJ_WORKSPACE}${YC}' was found in config${NC}"
        CURRENT_WORKSPACE="${PROJ_WORKSPACE}"
    
    # no project-specific, trying to detect
    else
        echo -e -n "${YC} >>> Detecting TF workspaces ... ${NC}"
        local workspaces_count="$( run_tf_workspace_list | grep -v -e '^\s*$' | wc -l )"
        echo "${workspaces_count} was detected"
        CURRENT_WORKSPACE="$( run_tf_workspace_list | grep '*' | tr -dc '[:alnum:]' | cut -d " " -f2 )"

        if [ ${workspaces_count} -gt 1 ] || [ ! "${CURRENT_WORKSPACE}" = "default" ]; then
            print_workspaces
            ask_input_workspace
        fi
    fi

    echo -e "${YC} >>> Selecting TF workspace ${RC}${CURRENT_WORKSPACE}${YC} ... ${NC}"
    run_docker ${TF_TOOL} workspace select ${CURRENT_WORKSPACE}
}

prepare_tfvars_params() {
    function normalize_filename() {
        local filename=$1
        if [[ "${filename}" = *.tfvars ]] || [[ "${filename}" = *.tfvars.json ]] || [[ "${filename}" = *.tfvars.hcl ]]; then
            echo "${filename}"
        else
            echo "${filename}.tfvars"
        fi
    }
    function ask_when_no_tfvars_file() {
        local filename="$( normalize_filename "$1" )"
        local file="${PROJ_DIR}/${filename}"

        if [ -f "${file}" ]; then
            echo "${filename}"
        else
            echo -e "Oops, file ${RC}${filename}${NC} was not found at ${YC}${PROJ_DIR}${NC} folder!" >&2
            echo -e "There are ${YC}*.tfvars${NC} files:" >&2
            eval "ls ${PROJ_DIR} | grep --color '.tfvars'" >&2

            read -p "Please input filename (with or without .tfvars extension) which one you want to work with: " filename
            echo "$( ask_when_no_tfvars_file "${filename}" )"
        fi
    }

    local result='' file='' override_file=''
    echo -e "${YC} >>> Searching for ${RC}tfvars${YC} file ... ${NC}" >&2

    # no pre-configured tfvars
    if [ -z "${PROJ_TFVAR}" ]; then
        echo -e "${YC} >>> No TFVARS files was found at the config, so will try current workspace '${RC}${CURRENT_WORKSPACE}${YC}' as a TFVARS filename${NC}" >&2
        file="$( ask_when_no_tfvars_file "${CURRENT_WORKSPACE}" )"
        result="-var-file=${file}"
    
    # pre-configured to skip tfvars
    elif [ "${PROJ_TFVAR}" = "${_SKIP_VALUE}" ]; then
        echo -e "${YC} >>> Skipping TFVARS because '${RC}${PROJ_TFVAR}${YC}' was found in alias config${NC}" >&2
        result=""
    
    # pre-configured tfvars, can be a list
    else
        echo -e "${YC} >>> TFVARS file(s) '${RC}$( echo ${PROJ_TFVAR[@]} | tr ' ' ', ' )${YC}' found in alias config${NC}" >&2
        for i in ${PROJ_TFVAR[@]}; do
            file="$( normalize_filename ${i} )"
            result="${result} -var-file=${file}"
            # lookup for an override files, adding it when exists
            override_file="$( get_override_file "${file}" )"
            [[ -f "${PROJ_DIR}/${override_file}" ]] && result="${result} -var-file=${override_file}"
        done
    fi

    echo "${result}"
}

#-----------------------------------------------------------#
# Helpers

ask_for_approve() {
    read -p "Are you sure to proceed? To approve print 'yes': " APPLY_APPROVE
    if [ ! "${APPLY_APPROVE}" = 'yes' ]; then
        echo -e "${YC} >>> Got no approve. Exiting ... ${NC}\n" >&2
        exit 0
    fi
}

is_debug_VERBOSITY_MODE() {
    [[ "${VERBOSITY_MODE}" -le "${VERBOSITY_DEBUG_MODE}" ]]
}

is_quick_mode() {
    (( "${TC_QUICK_MODE}" ))
}

get_override_file() {
    local file="$1"
    local suffix="$( get_sys_config '.override' 'config' 'override_file_suffix' )"
    echo "${file}" | sed -E "s/^(.*)(\.[[:alnum:]]+)$/\1${suffix}\2/g"
}

get_human_time_since_file_modified() {
    local file=$1
    local time=$(( $(date +%s) - $(stat -f%c "${file}") ))
    local sec=$((time%60))
    local min=$((time/60%60))
    local h=$((time/60/60%24))
    local d=$((time/60/60/24))
    (( ${d} > 0 )) && printf '%d days ' ${d}
    (( ${h} > 0 )) && printf '%d hours ' ${h}
    (( ${min} > 0 )) && printf '%d minutes ' ${min}
    (( ${d} > 0 || ${h} > 0 || ${min} > 0 )) && printf 'and '
    printf '%d seconds\n' ${sec}
}

# See @package: https://github.com/demmonico/bash-parse-yaml
# get config value from yaml config
# format: get_yaml_value YAML_FILE_NAME parent1 patent2 ... config_key_name
get_yaml_value() {
  if [ "$#" -lt 2 ]; then
    echo -e "${RC}Error:${NC} too few arguments at '${YC}get_yaml_value${NC}'"
    exit 1
  fi

  # Starting from Terra Compose v1.4 internally "&" used as a config levels separator
  local separator='&' prefix='' ALIAS_CONFIG=$1

  local config_path="${prefix}"
  for i in "${@:2}"; do
    [ -z "${config_path}" ] && config_path="${i}" || config_path="${config_path}${separator}${i}"
  done

  local k='[a-zA-Z0-9_]' # key name pattern
  local s='[[:space:]]*' fs=$(echo @|tr @ '\034')
  # normalise config. It's a shorter version from https://stackoverflow.com/a/21189044
  sed -ne "s|^\($s\):|\1|" \
      -e "s|^\($s\)\($k*\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
      -e "s|^\($s\)\($k*\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" $1 |
  # compose list of variables like parent1_parent2_target="target value" ("_" is a separator local variable)
  awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) { if (i > indent) { delete vname[i]; idx[i]=0 } };
      if (length($2) == 0) { vname[indent]= ++idx[indent] };
      
      # process value and compose the line
      val=$3
      if (length(val) > 0) {
         vn=""; for (i=0; i<indent; i++) { vn=(vn)(vname[i])("'${separator}'")}
         
         # for lists normalise separation (wrapping should be controlled by user itself, commas are not allowed inside the list elements!!!)
         if (val ~ /\[.*\]/) {
            gsub(/[[:blank:]+]?,[[:blank:]+]?/, ",", val);
         }
         # for other values - wrap them
         else {
            val = "\"" val "\""
         }
         # compose the line
         printf("%s%s%s=%s\n", "'${prefix:+${prefix}${separator}}'", vn, vname[indent], val);
      }
   }' |\
  # filter using pattern
  # Starting from Terra Compose v1.4 it compares config path strictly (before it was prefix search)
  grep -E "^${config_path}(${separator}|=)" | \
  # fetch value (string / list / map)
  {
    local trim_temp="" count_total=0
    declare -a config_results_single=()
    declare -a config_results_list=()
    declare -a config_results_map=()
    while read line; do
        # cut-off searched config_path and collect rest
        trim_temp="${line#*${config_path}}"
        # remove prefixed separator
        trim_temp="${trim_temp:1}"
        # collect single values
        if [[ "${trim_temp}" =~ ^\".*\"$ ]]; then
            config_results_single+=("${trim_temp}")
        # collect list values
        elif [[ "${trim_temp}" =~ ^\[.*\]$ ]]; then
            config_results_list+=("${trim_temp}")
        # collect map values (assuming it's the same map)
        else
            config_results_map+=("${trim_temp}")
        fi
    done

    ### validation: general rule is that we are looking for a single value (except maps)
    nl=$'\n'
    # mix of single, list and map values are not allowed
    if \
        # single + smth else OR list + smth else
        ([ "${#config_results_single[*]}" -gt 0 ] && ([ "${#config_results_list[*]}" -gt 0 ] || [ "${#config_results_map[*]}" -gt 0 ])) || \
        ([ "${#config_results_list[*]}" -gt 0 ] && ([ "${#config_results_single[*]}" -gt 0 ] || [ "${#config_results_map[*]}" -gt 0 ])); \
    then
        echo -e "${RC}Error:${NC} config path '${YC}${config_path}${NC}' contains mixed set of values (single, list, map), which is not allowed!" >&2
        echo -e "${RC}Singles:${NC} '${YC}${config_results_single[@]}${NC}'" >&2
        echo -e "${RC}Lists:${NC} '${YC}${config_results_list[@]}${NC}'" >&2
        echo -e "${RC}Maps:${NC} '${YC}${config_results_map[@]}${NC}'" >&2
        exit 1
    # a single value or a list should be exact one
    elif ([ "${#config_results_single[*]}" -gt 1 ] || [ "${#config_results_list[*]}" -gt 1 ]); then
        echo -e "${RC}Error:${NC} config path '${YC}${config_path}${NC}' contains more than one entry of a single value config or a list config, which is not allowed!" >&2
        echo -e "${RC}Singles:${NC} '${YC}${config_results_single[@]}${NC}'" >&2
        echo -e "${RC}Lists:${NC} '${YC}${config_results_list[@]}${NC}'" >&2
        exit 1
    # only flat maps are allowed
    elif ([ "${#config_results_map[*]}" -gt 1 ] && [[ "${config_results_map[@]}" =~ (^|$nl).+\&.+=\".*($|$nl) ]]); then
        echo -e "${RC}Error:${NC} config path '${YC}${config_path}${NC}' contains map having more than one layer values. Only flat maps are allowed!" >&2
        echo -e "${RC}Maps:${NC} '${YC}${config_results_map[@]}${NC}'" >&2
        exit 1
    fi

    ### processing
    local result
    # single value
    if [ "${#config_results_single[*]}" -gt 0 ]; then
        result=$( echo "${config_results_single[@]}" | sed -E 's/^.*"(.*)".*$/\1/g' ) # unwrap the quotes
    # list value
    elif [ "${#config_results_list[*]}" -gt 0 ]; then
        result=$( echo "${config_results_list[@]}" | sed -E 's/^\[|\]$//g' | tr ',' '\n' | sed 's/"//g' ) # remove opening/closing brackets, convert to multi-line string and unwrap the quotes
    # map value
    elif [ "${#config_results_map[*]}" -gt 0 ]; then        
        result="$( echo "${config_results_map[@]}" | tr ' ' '\n' | sed 's/"//g' )" # convert to multi-line string and unwrap the quotes
    fi

    echo "${result}"
  }
}

get_config() {
    if [ ! -f "${ALIAS_CONFIG}" ]; then
        echo -e "${RC}Error${NC}: No config files were found! ALIAS_CONFIG='${ALIAS_CONFIG}'" >&2
        exit 1
    fi

    local args=$@ result=''
    # normal flow, searching for the config
    if [ -n "${args}" ]; then
        result="$( get_yaml_value ${ALIAS_CONFIG} 'aliases' "${TC_ALIAS}" $@ )"
    # get all
    else
        result="$( cat ${ALIAS_CONFIG} | grep -v -E "^$|^\s*\#" )"
    fi
    
    echo "${result}"
}

get_sys_config() {
    local default=$1
    local config="${SYSTEM_CONFIG:-$HOME/.tc.yaml}"
    local args=${@:2}
    local result=''
    if [ -f "${config}" ]; then
        result="$( get_yaml_value ${config} $args )"
    fi
    if [ -z "${result}" ] && [ -n "${default}" ]; then
        result="${default}"
    fi
    echo "${result}"
}

#-----------------------------------------------------------#
# Main

init_app

# ----- read params ----- #

TC_ACTION=$1
case "${TC_ACTION}" in
    'plan' | 'apply' | 'workspaces' | 'run' | 'shell' )
        ;;
    'help')
        echo "${HELP_STRING}"
        exit;;
    '')
        echo -e "${RC}Error${NC}: ACTION param is required"
        echo "${HELP_STRING}"
        exit 1;;
    *)
        echo -e "${RC}Error:${NC} invalid action '${TC_ACTION}'"
        echo "${HELP_STRING}"
        exit 1;;
esac
shift

TC_ALIAS=$1
if [ -z "${TC_ALIAS}" ]; then
    echo -e "${RC}Error${NC}: ALIAS param is required"
    echo -e "${HELP_STRING}"
    exit 1
fi
shift

TC_QUICK_MODE='0'
TC_PASS_ARGS=
while [[ $# -gt 0 ]]; do
  key="$1"
  # pass rest args to the internal runtime
  if [ "$key" == "--" ]; then
    shift
    TC_PASS_ARGS=$@
    break
  fi
  # otherwise process args
  case $key in
    -q|--quick)     # quick mode flag, skipping init and validation and format checks
      TC_QUICK_MODE='1'
      ;;

    *)
      echo -e "${RC}Error:${NC} invalid param '$1'"
      exit 1
      ;;
  esac
  shift
done

# ----------------------- #

init_project

#-----------------------------------------------------------#
##### Main
#-----------------------------------------------------------#

run_host_hook 'before_all'

# TF action
case "${TC_ACTION}" in
    # uses the latest workspace. TODO
    'run')
        echo -e "${YC} >>> Running custom command ${RC}${TC_PASS_ARGS}${NC} at the alias ${YC}${TC_ALIAS} (${PROJ_DIR})${NC}."
        echo -e "${YC} >>> ${RC}Please, be carefull!!!${NC}"
        ask_for_approve

        run_docker ${TF_TOOL} ${TC_PASS_ARGS}
        exit;;

    # uses the latest workspace. TODO
    'shell')
        echo -e "${YC} >>> Shelling into the runtime container at the alias ${YC}${TC_ALIAS} (${PROJ_DIR})${NC}."
        echo -e "${YC} >>> ${RC}Please, be carefull!!!${NC}"
        ask_for_approve

        run_docker ${TC_PASS_ARGS}
        exit;;

    'workspaces')
        echo -e "${YC} >>> Workspace '${RC}${PROJ_WORKSPACE}${YC}' was found in alias config${NC}"
        echo -e "${YC} >>> Detecting TF workspaces ... ${NC}"
        print_workspaces
        exit;;
    
    'plan')
        # TF init
        run_tf_init
        
        # TF select workspace
        select_workspace

        # TF validation
        if ! is_quick_mode; then
            echo -e "${YC} >>> Checking format and validating TF templates ... ${NC}"
            run_docker ${TF_TOOL} fmt --check=true -recursive -diff
            run_docker ${TF_TOOL} validate
        fi

        # TF tfvars
        TFVARS_COMMAND_PARAM="$( prepare_tfvars_params )"

        # TF plan
        echo -e "\n------------------------------------------------------------------------\n"
        echo -e "${YC} >>> Building TF plan:${NC} alias ${YC}${TC_ALIAS}${NC} / workspace ${RC}${CURRENT_WORKSPACE}${NC} / tfvars ${RC}${TFVARS_COMMAND_PARAM}${NC}"
        echo -e "\n------------------------------------------------------------------------\n"
        run_docker ${TF_TOOL} plan ${TFVARS_COMMAND_PARAM} -out=${TF_PLAN_FILENAME} ${TC_PASS_ARGS}
        echo -e "\n${YC} >>> TF plan:${NC} alias ${YC}${TC_ALIAS}${NC} / workspace ${RC}${CURRENT_WORKSPACE}${NC} / tfvars ${RC}${TFVARS_COMMAND_PARAM}${NC}: was generated plan ${RC}${TF_PLAN_FILENAME}${NC}\n${YC} >>> ${NC}(${TF_PLAN_FILE})\n"
        exit;;

    'apply')
        # TF init
        run_tf_init
        
        # TF select workspace
        select_workspace

        # check TF plan
        if [ ! -f "${TF_PLAN_FILE}" ]; then
            echo -e "${RC}Error${NC}: TF plan file ${YC}${TF_PLAN_FILE}${NC} does not exists. \nPlease build TF plan first"
            exit 10
        fi

        # TF apply
        echo -e "\n------------------------------------------------------------------------\n"
        echo -e "${YC} >>> Applying TF plan:${NC} ${RC}${TF_PLAN_FILENAME}${NC} / alias ${YC}${TC_ALIAS}${NC} / workspace ${RC}${CURRENT_WORKSPACE}${NC}"
        echo -e "${YC} >>> ${NC}File ${YC}${TF_PLAN_FILE}${NC} was modified ${YC}$( get_human_time_since_file_modified "${TF_PLAN_FILE}" ) ago${NC}"
        echo -e "\n------------------------------------------------------------------------\n"
        
        echo -e "This action is going to run ${YC}terreform apply${NC} at the ${YC}${CURRENT_WORKSPACE}${NC} workspace"
        ask_for_approve

        run_docker ${TF_TOOL} apply ${TF_PLAN_FILENAME}
        # enable passed args ONLY for non-preapproved apply, when it will be done
        # run_docker ${TF_TOOL} apply ${TF_PLAN_FILENAME} ${TC_PASS_ARGS}
        echo -e "\n${YC} >>> TF apply:${NC} alias ${YC}${TC_ALIAS}${NC} / workspace ${RC}${CURRENT_WORKSPACE}${NC}: applied plan ${RC}${TF_PLAN_FILENAME}${NC}"

        rm ${TF_PLAN_FILE}
        echo -e "${YC} >>> ${NC}Plan ${YC}${TF_PLAN_FILE}${NC} has been ${RC}removed${NC}\n"
        exit;;

    *)
        echo -e "${RC}Error:${NC} Ooops, catch all for invalid action '${TC_ACTION}'"
        exit 1;;
esac

run_host_hook 'after_all'
